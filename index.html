<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wealth Planner & Net Worth Goal Tracker</title>
  <style>
    :root {
      --bg: #f8fafc;
      --card: #ffffff;
      --text: #0f172a;
      --muted: #475569;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --border: #e2e8f0;
      --danger: #b91c1c;
      --ok: #047857;
      --warn: #b45309;
      --shadow: 0 8px 30px rgba(15, 23, 42, 0.08);
    }
    body.dark {
      --bg: #020617;
      --card: #0f172a;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --accent-soft: #172554;
      --border: #1e293b;
      --danger: #fca5a5;
      --ok: #6ee7b7;
      --warn: #fdba74;
      --shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      transition: background 0.2s ease, color 0.2s ease;
    }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px; }
    .topbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .title h1 { margin: 0; font-size: 1.4rem; }
    .muted { color: var(--muted); font-size: 0.9rem; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: var(--accent-soft); color: var(--accent); font-size: 12px; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; }
    button, select, input, textarea {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      font: inherit;
    }
    textarea { width: 100%; min-height: 80px; }
    button { cursor: pointer; }
    button.primary { background: var(--accent); color: #fff; border-color: transparent; }
    button.danger { color: var(--danger); border-color: color-mix(in srgb, var(--danger) 40%, var(--border)); }
    .grid { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); }
    .card {
      grid-column: span 12;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .card h2 { margin: 0 0 8px; font-size: 1.05rem; }
    .fields { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    .metric-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; }
    .metric { background: var(--accent-soft); border-radius: 12px; padding: 10px; }
    .metric .name { font-size: 12px; color: var(--muted); }
    .metric .value { font-size: 1.2rem; font-weight: 700; }
    .metric small { font-size: 11px; color: var(--muted); }
    .progress-bar { height: 12px; border-radius: 999px; background: var(--border); overflow: hidden; }
    .progress-bar > div { height: 100%; background: linear-gradient(90deg, var(--accent), #22c55e); }
    .split { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    .chart-wrap { position: relative; height: 270px; }
    canvas { width: 100%; height: 100%; border: 1px solid var(--border); border-radius: 10px; background: var(--bg); }
    .list { max-height: 220px; overflow: auto; border: 1px solid var(--border); border-radius: 10px; }
    .list table { width: 100%; border-collapse: collapse; }
    .list th, .list td { padding: 6px 8px; border-bottom: 1px solid var(--border); font-size: 13px; text-align: left; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; }
    .ok { background: color-mix(in srgb, var(--ok) 20%, transparent); color: var(--ok); }
    .warn { background: color-mix(in srgb, var(--warn) 20%, transparent); color: var(--warn); }
    .bad { background: color-mix(in srgb, var(--danger) 20%, transparent); color: var(--danger); }
    .compact .optional { display: none; }
    .tooltip { border-bottom: 1px dashed var(--muted); cursor: help; }
    .footer-note { font-size: 12px; color: var(--muted); margin-top: 8px; }

    @media (min-width: 800px) {
      .span-6 { grid-column: span 6; }
      .span-4 { grid-column: span 4; }
      .span-8 { grid-column: span 8; }
    }
  </style>
</head>
<body>
  <div class="container" id="app">
    <div class="topbar">
      <div class="title">
        <h1>Wealth Planner & Net Worth Goal Tracker</h1>
        <div class="muted">Single-file app • offline-first • privacy-first <span class="pill">All data stays in your browser only</span></div>
      </div>
      <div class="controls">
        <button id="themeToggle">Toggle Theme</button>
        <button id="viewToggle">Compact/Expanded</button>
        <button id="exportJson">Export JSON</button>
        <button id="importJson">Import JSON</button>
        <button id="exportEncrypted">Encrypted Backup</button>
        <button id="importEncrypted">Restore Encrypted</button>
        <button class="danger" id="clearAll">Clear all data</button>
      </div>
    </div>

    <div class="grid">
      <section class="card span-8">
        <h2>Core Plan Inputs</h2>
        <div class="fields">
          <div><label>Current Net Worth ($)</label><input id="currentNetWorth" type="number" min="0" step="100" /></div>
          <div><label>Monthly Income ($)</label><input id="monthlyIncome" type="number" min="0" step="100" /></div>
          <div><label>Savings Rate (%)</label><input id="savingsRate" type="number" min="0" max="100" step="0.1" /></div>
          <div><label>Expected Annual Return (%)</label><input id="expectedReturn" type="number" step="0.1" /></div>
          <div><label>Inflation (%)</label><input id="inflationRate" type="number" step="0.1" /></div>
          <div><label>Sensitivity Return Drop (%)</label><input id="returnDrop" type="number" step="0.1" /></div>
        </div>
        <div class="footer-note">Validation is inline; unrealistic inputs are flagged in risk checks below.</div>
      </section>

      <section class="card span-4">
        <h2>Scenarios</h2>
        <div class="fields">
          <div><label>Active Scenario</label><select id="scenarioSelect"></select></div>
          <div><label>Scenario Name</label><input id="scenarioName" /></div>
          <div><label>Target Net Worth ($)</label><input id="targetNetWorth" type="number" min="1" step="1000" /></div>
          <div><label>Years to Target</label><input id="yearsToTarget" type="number" min="0.25" step="0.25" /></div>
          <div><label>Expected CAGR (%) <span class="tooltip" title="Used for scenario comparison; if blank, derived from expected annual return.">ⓘ</span></label><input id="scenarioCagr" type="number" step="0.1" /></div>
        </div>
        <div class="controls" style="margin-top:10px;">
          <button id="newScenario">New Scenario</button>
          <button id="deleteScenario">Delete</button>
        </div>
      </section>

      <section class="card span-12">
        <h2>Plan Metrics</h2>
        <div class="metric-grid" id="metricGrid"></div>
      </section>

      <section class="card span-8">
        <h2>Trajectory (Actual vs Required vs Projected)</h2>
        <div class="chart-wrap"><canvas id="trajectoryChart"></canvas></div>
      </section>

      <section class="card span-4 optional">
        <h2>Asset Allocation</h2>
        <div class="fields">
          <div><label>Cash ($)</label><input id="assetCash" type="number" min="0" step="100" /></div>
          <div><label>Equity ($)</label><input id="assetEquity" type="number" min="0" step="100" /></div>
          <div><label>Crypto ($)</label><input id="assetCrypto" type="number" min="0" step="100" /></div>
          <div><label>Real Estate ($)</label><input id="assetRealEstate" type="number" min="0" step="100" /></div>
          <div><label>Other ($)</label><input id="assetOther" type="number" min="0" step="100" /></div>
        </div>
        <div class="chart-wrap" style="height:220px;margin-top:10px;"><canvas id="allocationChart"></canvas></div>
      </section>

      <section class="card span-6">
        <h2>History & Journal</h2>
        <div class="fields">
          <div><label>Snapshot Date</label><input id="snapshotDate" type="month" /></div>
          <div><label>Net Worth Snapshot ($)</label><input id="snapshotValue" type="number" min="0" step="100" /></div>
        </div>
        <label>Monthly note</label>
        <textarea id="snapshotNote" placeholder="Wins, losses, lessons, behavior notes..."></textarea>
        <div class="controls" style="margin:8px 0;"><button class="primary" id="addSnapshot">Add/Update Snapshot</button><button id="exportCsv">Export CSV</button></div>
        <div class="list"><table><thead><tr><th>Month</th><th>Net Worth</th><th>Note</th></tr></thead><tbody id="historyRows"></tbody></table></div>
      </section>

      <section class="card span-6">
        <h2>Milestones & Execution</h2>
        <div id="milestoneSummary" class="split"></div>
        <div style="margin-top:10px;"><label>Progress to target</label><div class="progress-bar"><div id="goalProgress" style="width:0%"></div></div></div>
        <div class="list" style="margin-top:10px;"><table><thead><tr><th>Milestone</th><th>Target</th><th>Status</th></tr></thead><tbody id="milestoneRows"></tbody></table></div>
      </section>

      <section class="card span-12 optional">
        <h2>Scenario Comparison, Risk & Reality Checks</h2>
        <div class="split">
          <div>
            <h3>Side-by-side outcomes</h3>
            <div class="list"><table><thead><tr><th>Scenario</th><th>Target</th><th>Years</th><th>Req CAGR</th><th>Projected End</th></tr></thead><tbody id="scenarioComparisonRows"></tbody></table></div>
          </div>
          <div>
            <h3>Checks</h3>
            <div id="riskChecks"></div>
            <h3>Monte Carlo (lightweight)</h3>
            <div class="controls"><button id="runMonteCarlo">Run 300 simulations</button></div>
            <div id="monteCarloResult" class="muted">Run simulation to estimate probability of hitting your goal.</div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <input type="file" id="fileInput" accept="application/json" hidden />

  <script>
    /* Architecture: storage/persistence, state, calculations, and UI layers are intentionally separated. */
    const Storage = (() => {
      let memory = {};
      let enabled = true;
      try {
        localStorage.setItem('__t', '1');
        localStorage.removeItem('__t');
      } catch (_) { enabled = false; }
      return {
        get(key) { return enabled ? localStorage.getItem(key) : memory[key] || null; },
        set(key, val) { if (enabled) localStorage.setItem(key, val); else memory[key] = val; },
        remove(key) { if (enabled) localStorage.removeItem(key); else delete memory[key]; },
        clear() { if (enabled) localStorage.clear(); else memory = {}; },
        enabled
      };
    })();

    const DB = (() => {
      let db;
      const init = () => new Promise((resolve, reject) => {
        const req = indexedDB.open('wealth_planner_db', 1);
        req.onupgradeneeded = () => {
          const d = req.result;
          if (!d.objectStoreNames.contains('snapshots')) d.createObjectStore('snapshots', { keyPath: 'month' });
        };
        req.onsuccess = () => { db = req.result; resolve(); };
        req.onerror = () => reject(req.error);
      });
      const tx = (mode) => db.transaction('snapshots', mode).objectStore('snapshots');
      const getAll = () => new Promise((resolve, reject) => {
        const req = tx('readonly').getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b)=>a.month.localeCompare(b.month)));
        req.onerror = () => reject(req.error);
      });
      const put = (v) => new Promise((resolve, reject) => {
        const req = tx('readwrite').put(v); req.onsuccess = resolve; req.onerror = () => reject(req.error);
      });
      const clear = () => new Promise((resolve, reject) => {
        const req = tx('readwrite').clear(); req.onsuccess = resolve; req.onerror = () => reject(req.error);
      });
      return { init, getAll, put, clear };
    })();

    const defaultState = {
      theme: 'light',
      compact: false,
      currentNetWorth: 50000,
      monthlyIncome: 6000,
      savingsRate: 25,
      expectedReturn: 7,
      inflationRate: 2.5,
      returnDrop: 2,
      activeScenarioId: 'base',
      scenarios: {
        base: { id:'base', name:'Base', targetNetWorth: 1000000, yearsToTarget: 10, expectedCagr: 7 },
        aggressive: { id:'aggressive', name:'Aggressive', targetNetWorth: 1500000, yearsToTarget: 10, expectedCagr: 10 },
        conservative: { id:'conservative', name:'Conservative', targetNetWorth: 800000, yearsToTarget: 12, expectedCagr: 5 }
      },
      assets: { cash: 10000, equity: 30000, crypto: 4000, realEstate: 5000, other: 1000 }
    };

    let state = loadState();
    let history = [];

    function loadState() {
      const raw = Storage.get('wealth_planner_state');
      if (!raw) return structuredClone(defaultState);
      try {
        const parsed = JSON.parse(raw);
        return { ...structuredClone(defaultState), ...parsed, scenarios: { ...defaultState.scenarios, ...(parsed.scenarios || {}) }, assets: { ...defaultState.assets, ...(parsed.assets || {}) } };
      } catch {
        return structuredClone(defaultState);
      }
    }

    function persistState() {
      Storage.set('wealth_planner_state', JSON.stringify(state));
    }

    function fmtCurrency(v) {
      if (!isFinite(v)) return '—';
      return new Intl.NumberFormat(undefined, { style:'currency', currency:'USD', maximumFractionDigits:0 }).format(v);
    }
    function fmtPct(v, digits = 2) {
      if (!isFinite(v)) return '—';
      return `${v.toFixed(digits)}%`;
    }
    function parseNum(el, fallback = 0) { return Number.isFinite(+el.value) ? +el.value : fallback; }

    function currentScenario() { return state.scenarios[state.activeScenarioId]; }

    function calcMetrics(scenario = currentScenario()) {
      const current = state.currentNetWorth;
      const target = scenario.targetNetWorth;
      const years = Math.max(0.25, scenario.yearsToTarget);
      const months = Math.round(years * 12);
      const monthlyReturn = Math.pow(1 + state.expectedReturn / 100, 1 / 12) - 1;
      const reqCagr = current > 0 && target > 0 ? (Math.pow(target / current, 1 / years) - 1) * 100 : 0;
      const savingsMonthly = state.monthlyIncome * (state.savingsRate / 100);

      let projected = current;
      for (let i=0;i<months;i++) projected = projected * (1 + monthlyReturn) + savingsMonthly;

      // solve required monthly contribution by binary search
      let low = 0, high = Math.max(target, 1) * 2;
      for (let i=0;i<80;i++) {
        const mid = (low + high) / 2;
        let value = current;
        for (let m=0;m<months;m++) value = value * (1 + monthlyReturn) + mid;
        if (value >= target) high = mid; else low = mid;
      }
      const requiredContribution = high;
      const gap = projected - target;

      let reduced = current;
      const droppedMonthly = Math.pow(1 + Math.max(-0.99, (state.expectedReturn - state.returnDrop) / 100), 1 / 12) - 1;
      for (let i=0;i<months;i++) reduced = reduced * (1 + droppedMonthly) + savingsMonthly;

      let breakEvenMonths = 0, temp = current;
      while (temp < target && breakEvenMonths < 1200) {
        temp = temp * (1 + monthlyReturn) + savingsMonthly;
        breakEvenMonths++;
      }

      const inflationAdjTarget = target / Math.pow(1 + state.inflationRate / 100, years);
      const realCagr = ((1 + reqCagr / 100) / (1 + state.inflationRate / 100) - 1) * 100;

      return { current, target, years, months, reqCagr, requiredContribution, projected, gap, savingsMonthly, reduced, breakEvenMonths, inflationAdjTarget, realCagr };
    }

    function trajectoryData(metrics) {
      const monthlyReturn = Math.pow(1 + state.expectedReturn / 100, 1 / 12) - 1;
      const actual = history.map(h => ({ month: h.month, value: h.value }));
      const required = [];
      const projected = [];
      let req = metrics.current, proj = metrics.current;
      for (let m=0;m<=metrics.months;m++) {
        required.push({ m, value: metrics.current * Math.pow(1 + metrics.reqCagr / 100, m / 12) });
        projected.push({ m, value: proj });
        proj = proj * (1 + monthlyReturn) + metrics.savingsMonthly;
      }
      return { actual, required, projected };
    }

    function drawLineChart(canvas, datasets) {
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = w * dpr; canvas.height = h * dpr; ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, w, h);
      const pad = 32;
      const all = datasets.flatMap(d => d.points.map(p => p.y));
      const maxY = Math.max(...all, 1); const minY = 0;
      const maxX = Math.max(...datasets.flatMap(d=>d.points.map(p=>p.x)), 1);
      ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
      ctx.strokeRect(pad, pad, w - pad * 2, h - pad * 2);
      const xScale = x => pad + (x / maxX) * (w - pad * 2);
      const yScale = y => h - pad - ((y - minY) / (maxY - minY || 1)) * (h - pad * 2);
      for (let i=0;i<4;i++) {
        const y = pad + (i/4)*(h-pad*2);
        ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
      }
      datasets.forEach(ds => {
        ctx.strokeStyle = ds.color; ctx.lineWidth = 2; ctx.beginPath();
        ds.points.forEach((p, i) => { const x=xScale(p.x), y=yScale(p.y); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
        ctx.stroke();
      });
      ctx.font = '12px sans-serif'; ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--muted');
      ctx.fillText(fmtCurrency(maxY), 6, 14);
      datasets.forEach((ds, i) => { ctx.fillStyle = ds.color; ctx.fillRect(w - 140, 12 + i * 16, 10, 10); ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text'); ctx.fillText(ds.label, w - 126, 21 + i * 16); });
    }

    function drawPie(canvas, values) {
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = w * dpr; canvas.height = h * dpr; ctx.scale(dpr, dpr);
      ctx.clearRect(0,0,w,h);
      const entries = Object.entries(values).filter(([,v]) => v > 0);
      const total = entries.reduce((a,[,v])=>a+v,0) || 1;
      const colors = ['#60a5fa','#34d399','#f59e0b','#a78bfa','#f87171'];
      let angle = -Math.PI / 2;
      entries.forEach(([k,v],i)=>{
        const slice = (v/total)*Math.PI*2;
        ctx.beginPath(); ctx.moveTo(w/2,h/2); ctx.arc(w/2,h/2,Math.min(w,h)*0.35,angle,angle+slice); ctx.closePath();
        ctx.fillStyle = colors[i%colors.length]; ctx.fill();
        angle += slice;
      });
      ctx.font = '12px sans-serif';
      entries.forEach(([k,v],i)=>{ ctx.fillStyle = colors[i%colors.length]; ctx.fillRect(10, 10+i*16, 10, 10); ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text'); ctx.fillText(`${k}: ${((v/total)*100).toFixed(1)}%`, 24, 19+i*16); });
    }

    function render() {
      document.body.classList.toggle('dark', state.theme === 'dark');
      document.getElementById('app').classList.toggle('compact', state.compact);

      const scenario = currentScenario();
      const metrics = calcMetrics();

      // inputs
      const map = {
        currentNetWorth: state.currentNetWorth, monthlyIncome: state.monthlyIncome, savingsRate: state.savingsRate,
        expectedReturn: state.expectedReturn, inflationRate: state.inflationRate, returnDrop: state.returnDrop,
        scenarioName: scenario.name, targetNetWorth: scenario.targetNetWorth, yearsToTarget: scenario.yearsToTarget,
        scenarioCagr: scenario.expectedCagr, assetCash: state.assets.cash, assetEquity: state.assets.equity,
        assetCrypto: state.assets.crypto, assetRealEstate: state.assets.realEstate, assetOther: state.assets.other
      };
      Object.entries(map).forEach(([id, val]) => { const el = document.getElementById(id); if (document.activeElement !== el) el.value = val; });

      const select = document.getElementById('scenarioSelect');
      const options = Object.values(state.scenarios).map(s => `<option value="${s.id}">${s.name}</option>`).join('');
      select.innerHTML = options;
      select.value = state.activeScenarioId;

      document.getElementById('metricGrid').innerHTML = `
        <div class="metric"><div class="name">Target Multiple</div><div class="value">${(metrics.target / Math.max(metrics.current,1)).toFixed(2)}x</div></div>
        <div class="metric"><div class="name">Required CAGR <span class="tooltip" title="Annual growth rate needed to reach your goal from current net worth.">ⓘ</span></div><div class="value">${fmtPct(metrics.reqCagr)}</div></div>
        <div class="metric"><div class="name">Required Monthly Contribution</div><div class="value">${fmtCurrency(metrics.requiredContribution)}</div></div>
        <div class="metric"><div class="name">Projected Net Worth (at target date)</div><div class="value">${fmtCurrency(metrics.projected)}</div></div>
        <div class="metric"><div class="name">Gap Analysis</div><div class="value">${fmtCurrency(metrics.gap)}</div><small>${metrics.gap >= 0 ? 'Ahead of plan' : 'Behind plan'}</small></div>
        <div class="metric"><div class="name">This Month Target</div><div class="value">${fmtCurrency(requiredValueForCurrentMonth(metrics))}</div></div>
        <div class="metric"><div class="name">Next Milestone</div><div class="value">${fmtCurrency(nextMilestone(metrics).value)}</div><small>${nextMilestone(metrics).label}</small></div>
        <div class="metric"><div class="name">Streak (monthly updates)</div><div class="value">${computeStreak()} months</div></div>
        <div class="metric"><div class="name">Inflation-adjusted target</div><div class="value">${fmtCurrency(metrics.inflationAdjTarget)}</div></div>
        <div class="metric"><div class="name">Real CAGR</div><div class="value">${fmtPct(metrics.realCagr)}</div></div>
        <div class="metric"><div class="name">Sensitivity (${state.returnDrop}% lower returns)</div><div class="value">${fmtCurrency(metrics.reduced)}</div></div>
        <div class="metric"><div class="name">Break-even timeline</div><div class="value">${Math.floor(metrics.breakEvenMonths/12)}y ${metrics.breakEvenMonths%12}m</div></div>
      `;

      const progressPct = Math.max(0, Math.min(100, (metrics.current / Math.max(metrics.target,1)) * 100));
      document.getElementById('goalProgress').style.width = `${progressPct}%`;

      renderMilestones(metrics);
      renderHistory();
      renderScenarioComparison();
      renderRiskChecks(metrics);
      renderCharts(metrics);
      persistState();
    }

    function requiredValueForCurrentMonth(metrics) {
      const m = history.length ? history.length - 1 : 0;
      return metrics.current * Math.pow(1 + metrics.reqCagr / 100, m / 12);
    }

    function nextMilestone(metrics) {
      const marks = [0.25, 0.5, 0.75, 1].map(v => ({ value: metrics.target * v, label: `${Math.round(v*100)}% of target` }));
      return marks.find(m => metrics.current < m.value) || { value: metrics.target, label: 'Goal reached' };
    }

    function renderMilestones(metrics) {
      const annual = [];
      for (let y=1;y<=Math.ceil(metrics.years);y++) annual.push({ name: `Year ${y}`, value: metrics.current * Math.pow(1 + metrics.reqCagr/100, y) });
      const rows = [
        ...annual.map(a => ({ label: a.name, target: a.value })),
        ...[1,2,3,4].map(q => ({ label: `Quarter ${q} (yr1)`, target: metrics.current * Math.pow(1 + metrics.reqCagr/100, q/4) })),
        ...[1,2,3].map(m => ({ label: `Month ${m}`, target: metrics.current * Math.pow(1 + metrics.reqCagr/100, m/12) }))
      ];
      document.getElementById('milestoneRows').innerHTML = rows.map(r => `<tr><td>${r.label}</td><td>${fmtCurrency(r.target)}</td><td>${state.currentNetWorth >= r.target ? '<span class="badge ok">Done</span>' : '<span class="badge warn">Pending</span>'}</td></tr>`).join('');
      document.getElementById('milestoneSummary').innerHTML = `
        <div><div class="muted">Required monthly delta</div><strong>${fmtCurrency(metrics.requiredContribution - metrics.savingsMonthly)}</strong></div>
        <div><div class="muted">Time vs money tradeoff ( +1 year )</div><strong>${fmtCurrency(requiredContributionForYears(metrics.years + 1) - metrics.requiredContribution)}</strong></div>
      `;
    }

    function requiredContributionForYears(years) {
      const sc = currentScenario();
      const target = sc.targetNetWorth;
      const current = state.currentNetWorth;
      const months = Math.round(years * 12);
      const monthlyReturn = Math.pow(1 + state.expectedReturn / 100, 1 / 12) - 1;
      let low = 0, high = target * 2;
      for (let i=0;i<80;i++) {
        const mid = (low + high) / 2;
        let v = current;
        for (let m=0;m<months;m++) v = v * (1 + monthlyReturn) + mid;
        if (v >= target) high = mid; else low = mid;
      }
      return high;
    }

    function computeStreak() {
      if (!history.length) return 0;
      const set = new Set(history.map(h => h.month));
      let streak = 0;
      let d = new Date();
      while (true) {
        const month = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
        if (set.has(month)) { streak++; d.setMonth(d.getMonth()-1); }
        else break;
      }
      return streak;
    }

    function renderHistory() {
      document.getElementById('historyRows').innerHTML = history.slice().reverse().map(h => `<tr><td>${h.month}</td><td>${fmtCurrency(h.value)}</td><td>${(h.note || '').replace(/[<>]/g,'')}</td></tr>`).join('');
    }

    function renderScenarioComparison() {
      document.getElementById('scenarioComparisonRows').innerHTML = Object.values(state.scenarios).map(s => {
        const m = calcMetrics(s);
        return `<tr><td>${s.name}</td><td>${fmtCurrency(s.targetNetWorth)}</td><td>${s.yearsToTarget}</td><td>${fmtPct(m.reqCagr)}</td><td>${fmtCurrency(m.projected)}</td></tr>`;
      }).join('');
    }

    function renderRiskChecks(metrics) {
      const checks = [];
      if (metrics.reqCagr > 15) checks.push(['Extremely aggressive CAGR required.', 'bad']);
      else if (metrics.reqCagr > 10) checks.push(['High CAGR required; plan may be optimistic.', 'warn']);
      else checks.push(['CAGR is in a realistic range vs long-term benchmarks.', 'ok']);
      checks.push([`Benchmark: 60/40 ~6-8%, equities ~9-10%. Your required CAGR: ${fmtPct(metrics.reqCagr)}.`, 'warn']);
      checks.push([`Variance from required path right now: ${fmtCurrency(metrics.current - requiredValueForCurrentMonth(metrics))}.`, metrics.current >= requiredValueForCurrentMonth(metrics) ? 'ok' : 'warn']);
      document.getElementById('riskChecks').innerHTML = checks.map(c => `<div class="badge ${c[1]}" style="display:block; margin-bottom:6px;">${c[0]}</div>`).join('');
    }

    function renderCharts(metrics) {
      const t = trajectoryData(metrics);
      drawLineChart(document.getElementById('trajectoryChart'), [
        { label:'Required', color:'#f59e0b', points: t.required.map(p => ({ x: p.m, y: p.value })) },
        { label:'Projected', color:'#3b82f6', points: t.projected.map(p => ({ x: p.m, y: p.value })) },
        { label:'Actual', color:'#22c55e', points: t.actual.map((p,i) => ({ x: i, y: p.value })) }
      ]);
      drawPie(document.getElementById('allocationChart'), state.assets);
    }

    function bindEvents() {
      const updateAndRender = () => {
        const sc = currentScenario();
        state.currentNetWorth = parseNum(document.getElementById('currentNetWorth'), 0);
        state.monthlyIncome = parseNum(document.getElementById('monthlyIncome'), 0);
        state.savingsRate = Math.max(0, Math.min(100, parseNum(document.getElementById('savingsRate'), 0)));
        state.expectedReturn = parseNum(document.getElementById('expectedReturn'), 0);
        state.inflationRate = parseNum(document.getElementById('inflationRate'), 0);
        state.returnDrop = parseNum(document.getElementById('returnDrop'), 0);

        sc.name = document.getElementById('scenarioName').value || sc.name;
        sc.targetNetWorth = Math.max(1, parseNum(document.getElementById('targetNetWorth'), 1));
        sc.yearsToTarget = Math.max(0.25, parseNum(document.getElementById('yearsToTarget'), 1));
        sc.expectedCagr = parseNum(document.getElementById('scenarioCagr'), state.expectedReturn);

        state.assets.cash = parseNum(document.getElementById('assetCash'), 0);
        state.assets.equity = parseNum(document.getElementById('assetEquity'), 0);
        state.assets.crypto = parseNum(document.getElementById('assetCrypto'), 0);
        state.assets.realEstate = parseNum(document.getElementById('assetRealEstate'), 0);
        state.assets.other = parseNum(document.getElementById('assetOther'), 0);
        render();
      };

      document.querySelectorAll('input,textarea,select').forEach(el => el.addEventListener('input', updateAndRender));
      document.getElementById('scenarioSelect').addEventListener('change', e => { state.activeScenarioId = e.target.value; render(); });
      document.getElementById('newScenario').addEventListener('click', () => {
        const id = `custom_${Date.now()}`;
        state.scenarios[id] = { id, name:'Custom', targetNetWorth: 1200000, yearsToTarget: 10, expectedCagr: state.expectedReturn };
        state.activeScenarioId = id;
        render();
      });
      document.getElementById('deleteScenario').addEventListener('click', () => {
        if (Object.keys(state.scenarios).length <= 1) return;
        delete state.scenarios[state.activeScenarioId];
        state.activeScenarioId = Object.keys(state.scenarios)[0];
        render();
      });

      document.getElementById('themeToggle').addEventListener('click', () => { state.theme = state.theme === 'dark' ? 'light' : 'dark'; render(); });
      document.getElementById('viewToggle').addEventListener('click', () => { state.compact = !state.compact; render(); });

      document.getElementById('addSnapshot').addEventListener('click', async () => {
        const month = document.getElementById('snapshotDate').value;
        const value = parseNum(document.getElementById('snapshotValue'), NaN);
        const note = document.getElementById('snapshotNote').value.trim();
        if (!month || !isFinite(value)) return alert('Please provide month and net worth value.');
        await DB.put({ month, value, note, assets: state.assets });
        history = await DB.getAll();
        render();
      });

      document.getElementById('exportJson').addEventListener('click', async () => {
        const payload = { state, history: await DB.getAll(), exportedAt: new Date().toISOString() };
        downloadFile(`wealth-planner-${Date.now()}.json`, JSON.stringify(payload, null, 2), 'application/json');
      });

      document.getElementById('importJson').addEventListener('click', () => pickFile(async file => {
        const text = await file.text();
        const parsed = JSON.parse(text);
        if (parsed.state) state = { ...structuredClone(defaultState), ...parsed.state };
        if (Array.isArray(parsed.history)) {
          await DB.clear();
          for (const row of parsed.history) await DB.put(row);
          history = await DB.getAll();
        }
        render();
      }));

      document.getElementById('exportEncrypted').addEventListener('click', async () => {
        const pwd = prompt('Password for encrypted backup:');
        if (!pwd) return;
        const payload = JSON.stringify({ state, history: await DB.getAll(), exportedAt: new Date().toISOString() });
        const encrypted = await encryptPayload(payload, pwd);
        downloadFile(`wealth-planner-encrypted-${Date.now()}.json`, JSON.stringify(encrypted), 'application/json');
      });

      document.getElementById('importEncrypted').addEventListener('click', () => pickFile(async file => {
        const pwd = prompt('Password to decrypt backup:');
        if (!pwd) return;
        const encrypted = JSON.parse(await file.text());
        const text = await decryptPayload(encrypted, pwd);
        const parsed = JSON.parse(text);
        state = { ...structuredClone(defaultState), ...parsed.state };
        await DB.clear();
        for (const row of parsed.history || []) await DB.put(row);
        history = await DB.getAll();
        render();
      }));

      document.getElementById('clearAll').addEventListener('click', async () => {
        if (!confirm('Clear all local data from this browser? This cannot be undone.')) return;
        Storage.remove('wealth_planner_state');
        await DB.clear();
        state = structuredClone(defaultState);
        history = [];
        render();
      });

      document.getElementById('runMonteCarlo').addEventListener('click', () => {
        const runs = 300;
        const sc = currentScenario();
        let hits = 0;
        for (let i=0;i<runs;i++) {
          let v = state.currentNetWorth;
          const monthlySavings = state.monthlyIncome * (state.savingsRate/100);
          for (let m=0;m<Math.round(sc.yearsToTarget*12);m++) {
            const annual = randomNormal(state.expectedReturn/100, 0.12);
            const monthly = Math.pow(1 + annual, 1/12) - 1;
            v = v * (1 + monthly) + monthlySavings;
          }
          if (v >= sc.targetNetWorth) hits++;
        }
        document.getElementById('monteCarloResult').textContent = `Estimated probability of reaching target: ${(hits / runs * 100).toFixed(1)}% (${hits}/${runs}).`;
      });

      document.getElementById('exportCsv').addEventListener('click', async () => {
        const rows = await DB.getAll();
        const csv = ['month,netWorth,note', ...rows.map(r => `${r.month},${r.value},"${(r.note||'').replaceAll('"','""')}"`)].join('\n');
        downloadFile(`wealth-history-${Date.now()}.csv`, csv, 'text/csv');
      });
    }

    function randomNormal(mean, std) {
      const u = 1 - Math.random();
      const v = Math.random();
      return mean + std * Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }

    function pickFile(onFile) {
      const input = document.getElementById('fileInput');
      input.onchange = () => { if (input.files[0]) onFile(input.files[0]).catch(e => alert(`Import failed: ${e.message}`)); input.value = ''; };
      input.click();
    }

    function downloadFile(filename, content, mime) {
      const blob = new Blob([content], { type: mime });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 2000);
    }

    async function encryptPayload(plaintext, password) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveKey']);
      const key = await crypto.subtle.deriveKey({ name:'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' }, keyMaterial, { name:'AES-GCM', length:256 }, false, ['encrypt']);
      const encrypted = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, new TextEncoder().encode(plaintext));
      return { salt: b64(salt), iv: b64(iv), ciphertext: b64(new Uint8Array(encrypted)), v:1 };
    }

    async function decryptPayload(data, password) {
      const salt = fromB64(data.salt), iv = fromB64(data.iv), ciphertext = fromB64(data.ciphertext);
      const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveKey']);
      const key = await crypto.subtle.deriveKey({ name:'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' }, keyMaterial, { name:'AES-GCM', length:256 }, false, ['decrypt']);
      const decrypted = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, ciphertext);
      return new TextDecoder().decode(decrypted);
    }

    function b64(bytes) { return btoa(String.fromCharCode(...bytes)); }
    function fromB64(str) { return Uint8Array.from(atob(str), c => c.charCodeAt(0)); }

    (async function init() {
      try { await DB.init(); history = await DB.getAll(); }
      catch { history = []; }
      // auto-set snapshot helpers
      const now = new Date();
      document.getElementById('snapshotDate').value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
      document.getElementById('snapshotValue').value = state.currentNetWorth;
      bindEvents();
      render();
    })();
  </script>
</body>
</html>
